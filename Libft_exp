LIBFT EXPLICACINES

Crear librería.
Las funciones no deben terminar de forma inesperada (segfault, bus error, double fre...).
Toda la memoria asignada en el heap debe liberarse cuando sea necesario.
Entregar Makefile si se requiere, con flags -Wall -Wextra -Werror con cc, y el Makefile no debe hacer relink
El Makefile debe contener al menos las normas $(NAME), al, clean, fclean y re
Para entregar los bonus, regla bonus en el Makefile, en donde se añaden todos los headers, librerías o funciones que estén prohibidas en la parte principal del proyecto. Los bonus deben estar en archivos distintos _bonus.{c/h} 
Si tu proyecto permite el uso de la libft, hay que copiar su fuente y sus Makefile asociados en un directorio libft con su correspondiente Makefile. El Makefile de tu proyecto debe compilar primero la libreria utilizando su Makefile y después compilar el proyecto.
Solo se evalúa el trabajo entregado en el Git.

RESOLVER:
	¿CÓMO TENGO QUE PONER LAS FUNCIONES SI SÓLO SE PUEDE SUBIR UN ARCHIVO .c? Creo que se puede subir un archivo c por funcion...
	¿CÓMO SE HACÍA EL MAKEFILE? --> C_09
	¿CÓMO SE FUNCIONA CON UNA LIBRERÍA? --> 

Un archivo .h es un archivo de cabecera, contiene declaraciones de funciones, variables, constantes, estructuras, clases y otras definiciones que usan en uno o varios archivos fuente .c
	Macro de protección: técnica para evitar la inclusión múltiple del mismo archivo de cabecera dentro de un proyecto. Se implementa mediante las directivas preprocesador #ifndef, #define y #endif. Se define una macro única la primera vez que se incluye el archivo. Si el archivo intenta incluirla otra vez, el preprocesador detectará que la macro ya está definida y evitará preprocesar el contenido del archivo de nuevo. 
	
libft.a

Parte obligatoria:

Escribe tu propia librería: un conjunto de funciones que será una herramienta muy útil a lo largo del cursus.
No se puede declarar variables globales.
Si separamos una función compleja en varias, hay que utilizar la palabra static. BUSCAR A QUÉ SE REFIERE ESO!
Poner todos los archivo en la raíz del repositorio.
No entregar archivos que no se utilizan.
Todos los archivos .c se compilan con -Wall -Werror -Wextra
Utilizar comando ar para generar la librería. No se puede usar libtool.
El libft debe ser creado en la raíz del repositorio.

Funciones de libc:
• isalpha --> recibe un int, devuelve no cero si el caracter pertenece a la clase testeada y cero si no lo hace. 

• isdigit --> recibe un int, chequea que sea un dígito, del 0 al 9, devuelve no cero si es eso, y cero si no lo es. 
Tengo que meter el número entre ' ' , si no lo meto, tb me devuelve 0... ESTÁ ESO BIEN?? Sí que está bien, porque si meto un dígito sin '', lo que lee es esa posición en el ASCII... Y la posición 9 en el ASCII, por ej, es '\t'

• isalnum --> recibe un int, chequea que sea un caracter alfanumérico. 

• isascii --> recibe un int, chequea que sea un unsigned char de 7 bits que entra en el conjunto de caracteres ASCII 
Según chatgpt, la comprobación de que el argumento pasado a la función es un unsigned char de 7 bits se haría con la condición (c >= 0 && c <=127), sin complicarse. Eso es porque un unisgned char de 7 bits puede representar valores del 0 al 127, cualquier valor fuera de este rango no puede ser representado por un unisgned char de 7 bits.

• isprint --> recibe un int, chequea que sea un caracter imprimible, incuyendo espacio (del 32 al 126, ambos incluidos) 
Aunque isprint para 45 me da un valor superior a 1 (16384). Chatgpt dice que puede deberse a que es cosa de mi entorno de comilación particular

• strlen --> calcula la longitud de una string, excluyendo el byte nulo final. Devuelve el número de bytes en la string apuntada por el puntero s. 
Prototipo: size_t  strlen(const char *s)
	size_t es un tipo de dato que representa tamaños de objetos o que cuenta la cantidad de elementos. Es unsigned, sin signo. El tamaño de size_t varía según la arquitectura del sistema: en sistms de 32 bits es común que tenga 4 bytes y en sistemas de 63 bits puede tener 8 butes. Esto garantiza que size_t sea lo suficientemente grande como para almacenar cualquier tamaño que pueda manejar la plataforma. 
	const char * define un puntero de caracter constante. El contenido al que apunta el puntero no se puede modificar, pero el puntero en sí puede cambiar y apuntar a diferentes direcciones. 

• memset --> llena la memoria con un byte constante.
Prototipo: void    *memset(void *s, int c, size_t n)
LLena los primeros n bytes del área de memoria apuntada por s con el byte constante c. 
Devuelve un puntero al área de memoria s.
	void es un tipo de dato especial que se utiliza para indicar la ausencia de un valor o tipo específico. 
	Un puntero de tipo void (void *) es un puntero genérico que puede apuntar a un valor de cualquier tipo. Para manipular el valor auntado por un puntero void * es necesario convertir al tipo específico de datos mediante un casting. 

• bzero --> Borra los datos en los n bytes de la memoria empezando por la localización a la que apunta s, escribiendo ceros (bytes que contienen '\0') en ese área.
No devuelve nada.
Prototipo: 

• memcpy --> Copia n bytes del área de memoria src al área de memoria dest. Las áreas de memoria no se han de solapar/superponer. Devuelve un puntero a dest.
Prototipo: void    *ft_memcpy(void *dest, const void *src, size_t n)

	Para copiar los bytes de un puntero const void* a un puntero void* hay que tratar ambos punteros como unsigne char* o char*. Estos son los tipos de datos adecuados para manipular datos a nivel de bytes, ya que ocupan exactamente un byte.

• memmove --> copia n bytes del área de memoria src al área de memoria dest. Las áreas de memoria pueden superponerse: la copia tiene lugar de la siguiente manera: los bytes de src se copian primero en un array de memoria que no se superpone ni a src ni a dest, y después esos bytes de memoria se pasan del array temporal a dest.
Devuelve un puntero a dest.
Prototipo: void    *ft_memmove(void *dest, const void *src, size_t n);

Diferencia entre memcpy y memmove: cómo manejan el solapamiento (overlap). En memmove los datos de src desaparecen o se sobreescriben cuando se trasladan a la ubicación de dest. 
src es un const void*, eso significa que es inalterable. 
Pero si dest y src se solapan, memmove va a copiar src entero en dest, y lo que va a devolver es dest escrito sobre src. Lo que pasa es que no se han alterado los datos en src, si no que se han alterado en dest. Es raro de entender, pero más o menos eso. No alteramos los datos desde src, sino desde dest.

	if (char_dest < char_src || char_dest >= s + n)
	Para determinar solapamiento:
	si dest está antes de src, no hay solapamiento.
	si dest está después del final de src (s+n), tampoco hay solapamiento

• strlcpy --> copia una cadena de tamaño limitado. 
Prototipo: size_t  strlcpy(char *dst, const char *src, size_t size)
Toma el tamaño total del buffer, no solo su longitud, y garantiza un resultando terminado en carácter nulo. Se ha de incluir un byte para el carácter nulo en el size. Copia hasta size -1 caracteres de src a dst y pone caracter nulo final. 
Devuelve la longitud total de la cadena que ha intentado crear, es decir, la longitud de src

El strlcpy que tengo en ex10 de C02 no está bien...

Importante:
	si size es 0 no hay que copiar ningún caracter, pero sí que hay que devolver la longitud de src
	dst debe acabar en \0 si size es > 0
	El valor de retorno en strlcpy es la longitud de la cadena fuente, no la cantidad de caracteres copiados.


• strlcat --> concatenación de string de tamaño limitado.
Prototipo: size_t  strlcat(char *dst, const char *src, size_t size)
La función strlcat concatena cadenas. Se supone que es más segura, consistente y menos propensa al error que strncat. Toma todo el tamaño del buffer, no solo su longitud, y garantiza un resultado que termina en NULL, mientras que el size sea mayor que 0 o mientras que quede al menos un byte libre en dst. El byte para el caracter nulo tiene que estar incluido en size. strlcat solo opera en verdaderas strings de C, lo que significa que src y dst tienen que terminar en carácter nulo.
La función strlcat añade la cadena terminada en caracter nulo de src al final de dest. Añade a lo sumo el size (strlen(dest)) 1 byte, dando final de carácter nulo.
Devuelve la longitud total de la cadena que ha intentado crear, sumando la longitud inicial de dest a la longitud de src.

DIFERENCIA ENTRE TAMAÑO DE BUFFER Y SU LONGITUD:
Buffer: región de memoria del ordenador, reservada para almacenar datos. En C, un buffer es un arreglo de caracteres (char array) que se usa para almacenar una cadena.
El tamaño del buffer es la cantidad total de espacio en memoria que ha sido reservado para el buffer. Incluye el espacio para todos los caracteres de la cadena más el carácter nulo final. El tamaño de char buffer[10] son 10 caracteres.
La longitud de la cadena es el número de caracteres que tiene, excluyendo el carácter nulo final. La longitud de la cadena "Hello" es 5, aunque esté almacenado en un buffer de tamaño 10.

• toupper --> si c es una letra minúscula, devuelve su equivalente en mayúscula, si existe mayúscula en el local. Si no existe, devuelve c.
Prototipo: int     toupper(int c)

• tolower --> si c es mayúscula, devuelve su equivalente en minúscula, si existe en el local. Si no, devuelve c. 
Prototipo: int     tolower(int c)

• strchr --> devuelve un puntero a la primera ocurrencia del caracter c en la string s. Aquí, caracter quiere decir byte. No funciona con caracteres anchos o multibyte. Devuelve NULL si no encuentra el caracter. El caracter nulo final se considera parte de la string, así que si c fuese '\0', se retornaría un puntero a a ahí. 
Prototipo: char    *ft_strchr(const char *s, int c)

• strrchr --> Devuelve un puntero a la última ocurrencia del caracter c en la string s. Devuelve NULL si no lo encuentra. El caracter nulo final se considera parte de la string, así que si c es == '\0', la función devuelve el puntero al final.
Protitipo: char    *ft_strrchr(const char *s, int c)

• strncmp --> compara dos strings. 
Prototipo: int     strncmp(const char *s1, const char *s2, size_t n)
strncmp compara los primeros n bytes de s1 y s2. Devuelve un int menor que, igual a o mayor que 0 si los primeros n bytes de s1 son menores, iguales o mayores que los de s2, respectivamente.

• memchr -->  Escanea los primeros n bytes del área de memoria a la que apunta s para la primera instancia de c. Tanto c como los bytes de memoria a los que apunta s se interpretan como unsigned char.
Devuelve un puntero al byte que hace match o NULL si el caracter no se da en el área de memoria dada.
Prototipo: void    *memchr(const void *s, int c, size_t n)


• memcmp --> Compara áreas de memoria. Compara los primeros n bytes (interpretados como unsigned char) de las áreas de memoria s1 y s2.
Devuelve un int menor que, igual a o mayor a cero si los primeros n bytes de s1 son menor que, iguales o mayores que los primeros n bytes de s2. Para un resultado no cero, el signo determina la diferencia entre el primer par de bytes comparados, de s1 y s2...
Si n es cero, el valor devuelto es 0.


• strnstr --> localiza una substring en una string.
Prototipo: char *ft_strnstr(const char *big, const char *little, size_t len)
Localiza la primera ocurrencia de la string little (que termina en nulo) en la string big, no se buscan más que los len caracteres. Según chatgpt, esto significa que len hace referencia a la cantidad máxima de caracteres en la cadena big que serán buscados para encontrar la primera ocurrencia de little. Es decir, se examinarán los primeros len caracteres de big.
Los caracteres que aparecen después del \0 no se buscan. 
Devuelve: si little es una string vacía, devuelve big. Si little no aparece en big, devuelve NULL. En los otros casos, se devuelve un puntero al primer caracter de la primera ocurrencia de little.

• atoi --> convierte la porción inicial de la string apuntada por nptr a int. Mismo comportamiento que strtol(nptr, NULL, 10), solo que atoi no detecta errores. 
Devuelve el valor convertido o 0 en caso de error.

	INT_MIN --> -2147483648
	INT_MAX --> 2147483647
	
	¿Qué errores detecta strtol que atoi ignora, pero en los cuales devuelve 0?
		strstol acepta un número arbitrario de espacios (isspace(3)), seguidos de un único y opcional + o -)
		Se para de pasar el número a int cuando se encuentra un caracter que no es un dígito válido.
		Si no hay dígitos, devuelve 0.
		Si el valor underflowea o overflowea, devuelve LONG_MIN o LONG_MAX respectivamente. En ambos casos se manda un error. En este caso, el atoi debería mandar 0?
		

• calloc --> Asigna la memoria de un array de nmemb elementos de size bytes de tamaño y devuelve un puntero a la memoria asignada. La memoria se pone en cero. Si nmemb o size son 0, calloc puede retornar NULL o un puntero único de tamaño 0 (se supone, no entiendo bien) que después se puede pasar a free().Si la multiplicación de nmemb y size da un int overflow, calloc devuelve error. En cambio, un int overflow no será detectado en la siguiente llamada a malloc, con el resultado de que se asignará un bloque de memoria incorrectamente.
calloc() devuelve un puntero a la memoria asignada, que está adecuadamente alineada para cualquier tipo de built-int. Si hay error, devuelven NULL. Tb devuelve NULL si nmemb o size son 0.
 
Prototipo: void    *calloc(size_t nmemb, size_t size);

• strdup --> devuelve un puntero a una nueva string que es un duplicado de la string s. La memoria para la nueva string se obtiene de malloc y puede ser liberada con free.
Devuelve NULL si no hay suficiente memoria disponible, con errno indicando la causa del error.
Prototipo: char    *ft_strdup(const char *s)




Funciones adicionales:

• ft_substr --> reserva memoria con malloc(3) y devuelve una substring de la string s, que empieza desde el índie start y tiene longitud máxima len.
Devuelve la substring resultante y NULL si falla la reserva de memoria.
Prototipo: i

• ft_strjoin --> genera una nueva string añadiendo la string s2 a la string s1. Devuelve NULL si falla la memoria. Reserva con malloc(3) y devuelve una nueva string formada por la concatenación de s1 y s2.
Prototipo: char *ft_strjoin(char const *s1, char const *s2)

• ft_strtrim --> Elimina todos los caracteres de la string set desde el principio hasta el final de la string s1, hasta encontrar un caracter no perteneciente a set. La string resultante se devuelve con una reserva de malloc. 
Devuelve la string recortada. Devuelve NULL si falla la reserva de memoria.
Prototipo: char    *ft_strtrim(char const *s1, char const *set)

• ft_split --> Reserva con malloc un array de strings resultante de separar la string s en substrings utilizando el caracter c como delimitador. El array termina con un puntero NULL.
Hay que usar malloc y free.
Devuelve el array de nuevas strings resultante de la separación o NULL si falla la reserva de memoria.
Prototipo: char    **ft_split(char const *s, char c);


• ft_itoa --> Utilizando malloc genera una string que represente el valor entero recibido como argumento. Hay que gestionar los números negativos. Devuelve la string que representa al número o NULL si falla la reserva de memoria.

Se parece a putnbr.


• ft_strmapi --> Aplica la función f a cada caracter de la cadena s, pasando su índice como primer argumento y el propio caracter como segundo argumento. Se crea una nueva cadena utilizando malloc para recoger los resultados de las sucesivas aplicaciones de f. Devuelve la string resultante o NULL si falla la reserva de memoria.
Prototipo: char    *ft_strmapi(char const *s, char (*f)(unsigned int, char))

En C se puede pasar una función como argumento de otra función usando punteros funcionales. 

ft_strmapi recorrerá cada caracter de s. En cada caracter aplicará la función f, cuyos argumentos son el índice del carácter (su posición en la cadena) y el propio caracter. El resultado de aplicar f a cada caracter será almacenado en una nueva cadena creada con malloc. 
Pasos: 
	asignar memoria para la nueva cadena con malloc.
	iterar a través de la cadena original s.
	aplicar la función f a cada caracter, almacenando el resultado en la nueva cadena.
	que la nueva cadena acabe en carácter nulo final.

• ft_striteri --> A cada caracter de la string s, aplica la función f, dando como parámetros el índice de cada carácter dentro de s y la dirección del propio aracter, que podrá modificarse si es necesario. 
Prototipo: void    ft_striteri(char *s, void (*f)(unsigned int, char*))




• ft_substr

• ft_putchar_fd --> Envía el caracter c al file descriptor especificado.

	File descriptor (fd): abstracción para manejar recursos entrada/salida (I/O). Es un número entero que el kernel del sistema operativo asigna a un programa cuando este abre un archivo o algún otro recurso que requiere I/O. 
	Cuando abres un archivo en C usando la función open(), el sistm operativo devuelve un file descriptor.
	
Funciones autorizadas: write
void    ft_putchar_fd(char c, int fd)

	Cómo funciona write --> ssize_t write(int fd, const void *buf, size_t count)
	
• ft_putstr_fd --> Envía la string s al file descriptor especificado.
void    ft_putstr_fd(char *s, int fd)

• ft_putendl_fd --> Envía la string s al file descriptor dado, seguido de un salto de línea.
Para ver el salto de línea con cat -->
cat -A archivo

• ft_putnbr_fd --> Envía el número n al file descritor dado.


LIBFT.H -->
	¿Cómo usar la biblioteca?
	Una vez creada la libft.a con el Makefile y eso --> 
	En la terminal:
	cc main.c -L. -lft -I.
		
		-L para indicar el directorio en el que se encuentra la biblioteca. Si estamos en ese directorio, poner -L.
		- lft --> -l es para indicar el nombre de la biblioteca, omitiendo lib y el sufijo .a --> libft.a se convierte en ft. La 'l' es como la orden.
		-I. --> para que busque los archivos de cabecera en el direcotiro actual
		

PARTE BONUS:

Estructuras, listas --> explicaciones en C08...
En el Makefile --> regla make bonus que incorpore las funciones bonus a la libft.a
	
